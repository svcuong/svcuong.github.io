<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Data Visualization | Data Science</title>
    <link>/tag/data-visualization/</link>
      <atom:link href="/tag/data-visualization/index.xml" rel="self" type="application/rss+xml" />
    <description>Data Visualization</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Sun, 23 Aug 2020 00:00:00 +0000</lastBuildDate>
    <image>
      <url>/images/icon_hu47efca792e1e7000f9078d7b8f1dac48_31011_512x512_fill_lanczos_center_2.PNG</url>
      <title>Data Visualization</title>
      <link>/tag/data-visualization/</link>
    </image>
    
    <item>
      <title>Phương pháp Ensemble Learning trong Machine Learning: Boosting, Bagging, Stacking (Sử dụng R code)</title>
      <link>/post/ensemble-learning/</link>
      <pubDate>Sun, 23 Aug 2020 00:00:00 +0000</pubDate>
      <guid>/post/ensemble-learning/</guid>
      <description>


&lt;p&gt;Trong &lt;code&gt;machine learning&lt;/code&gt; tồn tại định lý &lt;em&gt;“không có bữa trưa miễn phí”&lt;/em&gt; (&lt;code&gt;No free lunch theorem&lt;/code&gt;), tức là không tồn tại một thuật toán mà luôn tốt cho mọi ứng dụng và mọi tập dữ liệu, vì các thuật toán &lt;code&gt;machiner learning&lt;/code&gt; thường dựa trên một tập các tham số (&lt;code&gt;hyperparameters&lt;/code&gt;) hoặc một giả thiết nhất định nào đó về phân bố dữ liệu. Vì vậy để tìm được những thuật toán phù hợp cho tập &lt;code&gt;dataset&lt;/code&gt; của mình có thể các bạn sẽ cần nhiều thời gian để &lt;code&gt;test&lt;/code&gt; các thuật toán khác nhau. Rồi từ đó thực hiện hiệu chỉnh các tham số (&lt;code&gt;tuning hyperparameters&lt;/code&gt;) của thuật toán để thu được độ chính xác cao nhất.&lt;/p&gt;
&lt;p&gt;Một cách khác có thể sử dụng để tăng độ chính xác trên tập &lt;code&gt;dataset&lt;/code&gt; của bạn là kết hợp (&lt;code&gt;combine&lt;/code&gt;) một số mô hình với nhau. Phương pháp này gọi là &lt;code&gt;esemble learning&lt;/code&gt;. Ý tưởng của việc &lt;code&gt;combine&lt;/code&gt; các mô hình khác nhau xuất phát từ một suy nghĩ hợp lý là: các mô hình khác nhau có khả năng khác nhau, có thể thực hiện tốt nhất các loại công việc khác nhau (&lt;code&gt;subtasks&lt;/code&gt;), khi kết hợp các mô hình này với nhau một cách hợp lý thì sẽ tạo thành một mô hình kết hợp (&lt;code&gt;combined model&lt;/code&gt;) mạnh có khả năng cải thiện hiệu suât tổng thể (&lt;code&gt;overall performance&lt;/code&gt;) so với việc chỉ dùng các mô hình một cách đơn lẻ.&lt;/p&gt;
&lt;p&gt;Các phương pháp &lt;code&gt;Ensemble Learning&lt;/code&gt; được chia thành 3 loại sau đây:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Bagging&lt;/code&gt; (đóng bao)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Boosting&lt;/code&gt; (tăng cường)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Stacking&lt;/code&gt; (Xếp chồng)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Trong post này, trước hết tôi sẽ giới thiệu 3 kỹ thuật &lt;code&gt;ensemble learning&lt;/code&gt; kể trên, sau đó là cách sử dụng thư viện &lt;code&gt;caret&lt;/code&gt; và &lt;code&gt;caretEnsemble&lt;/code&gt; trong &lt;code&gt;R&lt;/code&gt; để triển khai chúng và áp dụng vào bài toán cụ thể.&lt;/p&gt;
&lt;p&gt;Để cài đặt 2 thư viện này ta dùng lệnh &lt;code&gt;install.packages(.)&lt;/code&gt; với tham số đầu vào là tên thư viện muốn cài:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;install.packages(&amp;quot;caret&amp;quot;)
intall.packages(&amp;quot;caretEnsemble&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Đôi nét về thư viện caret&lt;/strong&gt;: Ngôn ngữ &lt;code&gt;R&lt;/code&gt; khác biệt bởi số lượng rất lớn các &lt;code&gt;packages&lt;/code&gt; chuyên dụng khác nhau cho phép xây dựng các mô hình dự đoán. Tuy nhiên đây cũng chính là khuyết điểm, khi có quá nhiều các gói triển khai &lt;code&gt;machine learning algorithms&lt;/code&gt; dưới dạng các
hàm &lt;code&gt;rải rác&lt;/code&gt; đòi hỏi ta cần nhiều thời gian để tìm kiếm và nắm vững những đặc trưng về cú pháp cũng như cách sử dụng của từng hàm. Để giải quyết vấn đề này &lt;a href=&#34;https://www.linkedin.com/in/max-kuhn-864a9110&#34;&gt;Max Kuhn&lt;/a&gt; đã xây dựng một giao diện phổ quát cho phép truy cập và sử dụng các &lt;code&gt;machine learning algorithms&lt;/code&gt; từ cái gói khác nhau được triển khai trên ngôn ngữ &lt;code&gt;R&lt;/code&gt;. Kết quả chính là package &lt;a href=&#34;https://cran.r-project.org/web/packages/caret/caret.pdf&#34;&gt;caret&lt;/a&gt; (viết tắt từ Classification and Regression Training), được công bố đầu tiên vào năm 2008 tại tạp chí phần mềm thống kê &lt;a href=&#34;https://www.jstatsoft.org/article/view/v028i05&#34;&gt;Journal of Statistical Software&lt;/a&gt;. Gói &lt;code&gt;caret&lt;/code&gt; giúp chúng ta tiết kiệm được rất nhiều thời gian trong quá trình phân tích và xây dựng các &lt;code&gt;models&lt;/code&gt;. Dưới đây là một số
đặc trưng cơ bản của gói &lt;code&gt;caret&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Sử dụng cú pháp lệnh chung (phổ quát) không phụ thuộc vào cú pháp của các hàm gốc (các hàm triển khai các machine learningalgorithms)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Tự động tìm kiếm những giá trị tối ưu cho các &lt;code&gt;hyperparameters&lt;/code&gt; của mô hình (&lt;code&gt;tuning parameters&lt;/code&gt;)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Có khả năng tổ chức tính toán song song để tăng đáng kể tốc độ quá trình huấn luyện mô hình&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Sử dụng &lt;code&gt;Caret&lt;/code&gt; cho phép giải quyết hầu hết các nhiệm vụ trong &lt;code&gt;machine learning&lt;/code&gt; từ tiền xủ lý cho đến đánh giá mô hình&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;1. Phân biệt 3 kỹ thuật boosting, baggig và statcking&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Bagging&lt;/strong&gt; xây dựng một lượng lớn các &lt;code&gt;models&lt;/code&gt; (thường là &lt;code&gt;cùng loại&lt;/code&gt;) trên những &lt;code&gt;subsamples&lt;/code&gt; khác nhau từ tập &lt;code&gt;training dataset&lt;/code&gt; một cách song song nhằm đưa ra dự đoán tốt hơn.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Boosting&lt;/strong&gt; xây dựng một lượng lớn các &lt;code&gt;models&lt;/code&gt; (thường là &lt;code&gt;cùng loại&lt;/code&gt;). Tuy nhiên quá trình huấn luyện trong phương pháp này diễn ra tuần tự theo chuỗi (sequence). Trong chuỗi này mỗi &lt;code&gt;model&lt;/code&gt; sau sẽ học cách sửa những &lt;code&gt;errors&lt;/code&gt; của &lt;code&gt;model&lt;/code&gt; trước (hay nói cách khác là dữ liệu mà &lt;code&gt;model&lt;/code&gt; trước dự đoán sai).&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;/img/boosting-bagging.png&#34; alt=&#34;Nguồn ảnh&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;&lt;a href=&#34;https://www.datacamp.com/community/tutorials/adaboost-classifier-python&#34;&gt;Nguồn ảnh&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Stacking&lt;/strong&gt; xây dựng một số &lt;code&gt;models&lt;/code&gt; (thường là &lt;code&gt;khác loại&lt;/code&gt;) và một mô hình &lt;code&gt;supervisor model&lt;/code&gt;, mô hình này sẽ học cách kết hợp kết quả dự báo của một số mô hình một cách tốt nhất.&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;/img/stacking.png&#34; alt=&#34;Nguồn ảnh&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/stacking-in-machine-learning/&#34;&gt;Nguồn ảnh&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2. Thực hành&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Nạp các thư viện cần dùng vào phiên làm việc của &lt;code&gt;R&lt;/code&gt; để thực hành:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(caret)
library(caretEnsemble) &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Kiểm tra số lượng các machine learning algorithms trong R được hỗ trợ bởi &lt;code&gt;caret&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;carets &amp;lt;- getModelInfo()
carets.names &amp;lt;- names(carets)
length(carets.names)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 238&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2.1 Dữ liệu để thực hành&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Để thực hành tôi lựa chọn bài toán phân loại nhị phân (&lt;code&gt;binary classification&lt;/code&gt;) với tập dữ liệu &lt;code&gt;ionoshene&lt;/code&gt;. Trong bài toán này chúng ta cần dự đoán xem cao tần trả vể từ năng lượng của các hạt trong khí quyển có cấu trúc hay là không. Để tìm hiểu thêm về bài toán này các bạn có thể đọc ở &lt;a href=&#34;http://archive.ics.uci.edu/ml/index.php&#34;&gt;đây&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Load dữ liệu từ gói &lt;code&gt;mlbench&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Load the dataset
library(mlbench)
data(Ionosphere)
dataset &amp;lt;- Ionosphere&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2.1.1 Thống kê mô tả (descriptive statistics)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Kiểm tra kích thước tập dữ liệu:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dim(dataset)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 351  35&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Kiểm tra cấu trúc của tập dữ liệu:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;str(dataset)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## &amp;#39;data.frame&amp;#39;:    351 obs. of  35 variables:
##  $ V1   : Factor w/ 2 levels &amp;quot;0&amp;quot;,&amp;quot;1&amp;quot;: 2 2 2 2 2 2 2 1 2 2 ...
##  $ V2   : Factor w/ 1 level &amp;quot;0&amp;quot;: 1 1 1 1 1 1 1 1 1 1 ...
##  $ V3   : num  0.995 1 1 1 1 ...
##  $ V4   : num  -0.0589 -0.1883 -0.0336 -0.4516 -0.024 ...
##  $ V5   : num  0.852 0.93 1 1 0.941 ...
##  $ V6   : num  0.02306 -0.36156 0.00485 1 0.06531 ...
##  $ V7   : num  0.834 -0.109 1 0.712 0.921 ...
##  $ V8   : num  -0.377 -0.936 -0.121 -1 -0.233 ...
##  $ V9   : num  1 1 0.89 0 0.772 ...
##  $ V10  : num  0.0376 -0.0455 0.012 0 -0.164 ...
##  $ V11  : num  0.852 0.509 0.731 0 0.528 ...
##  $ V12  : num  -0.1776 -0.6774 0.0535 0 -0.2028 ...
##  $ V13  : num  0.598 0.344 0.854 0 0.564 ...
##  $ V14  : num  -0.44945 -0.69707 0.00827 0 -0.00712 ...
##  $ V15  : num  0.605 -0.517 0.546 -1 0.344 ...
##  $ V16  : num  -0.38223 -0.97515 0.00299 0.14516 -0.27457 ...
##  $ V17  : num  0.844 0.055 0.838 0.541 0.529 ...
##  $ V18  : num  -0.385 -0.622 -0.136 -0.393 -0.218 ...
##  $ V19  : num  0.582 0.331 0.755 -1 0.451 ...
##  $ V20  : num  -0.3219 -1 -0.0854 -0.5447 -0.1781 ...
##  $ V21  : num  0.5697 -0.1315 0.7089 -0.6997 0.0598 ...
##  $ V22  : num  -0.297 -0.453 -0.275 1 -0.356 ...
##  $ V23  : num  0.3695 -0.1806 0.4339 0 0.0231 ...
##  $ V24  : num  -0.474 -0.357 -0.121 0 -0.529 ...
##  $ V25  : num  0.5681 -0.2033 0.5753 1 0.0329 ...
##  $ V26  : num  -0.512 -0.266 -0.402 0.907 -0.652 ...
##  $ V27  : num  0.411 -0.205 0.59 0.516 0.133 ...
##  $ V28  : num  -0.462 -0.184 -0.221 1 -0.532 ...
##  $ V29  : num  0.2127 -0.1904 0.431 1 0.0243 ...
##  $ V30  : num  -0.341 -0.116 -0.174 -0.201 -0.622 ...
##  $ V31  : num  0.4227 -0.1663 0.6044 0.2568 -0.0571 ...
##  $ V32  : num  -0.5449 -0.0629 -0.2418 1 -0.5957 ...
##  $ V33  : num  0.1864 -0.1374 0.5605 -0.3238 -0.0461 ...
##  $ V34  : num  -0.453 -0.0245 -0.3824 1 -0.657 ...
##  $ Class: Factor w/ 2 levels &amp;quot;bad&amp;quot;,&amp;quot;good&amp;quot;: 2 1 2 1 2 1 2 1 2 1 ...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Hiển thị &lt;code&gt;5&lt;/code&gt; hàng dữ liệu đầu tiên:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;head(dataset, 5)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   V1 V2      V3       V4      V5       V6       V7       V8      V9      V10
## 1  1  0 0.99539 -0.05889 0.85243  0.02306  0.83398 -0.37708 1.00000  0.03760
## 2  1  0 1.00000 -0.18829 0.93035 -0.36156 -0.10868 -0.93597 1.00000 -0.04549
## 3  1  0 1.00000 -0.03365 1.00000  0.00485  1.00000 -0.12062 0.88965  0.01198
## 4  1  0 1.00000 -0.45161 1.00000  1.00000  0.71216 -1.00000 0.00000  0.00000
## 5  1  0 1.00000 -0.02401 0.94140  0.06531  0.92106 -0.23255 0.77152 -0.16399
##       V11      V12     V13      V14      V15      V16     V17      V18      V19
## 1 0.85243 -0.17755 0.59755 -0.44945  0.60536 -0.38223 0.84356 -0.38542  0.58212
## 2 0.50874 -0.67743 0.34432 -0.69707 -0.51685 -0.97515 0.05499 -0.62237  0.33109
## 3 0.73082  0.05346 0.85443  0.00827  0.54591  0.00299 0.83775 -0.13644  0.75535
## 4 0.00000  0.00000 0.00000  0.00000 -1.00000  0.14516 0.54094 -0.39330 -1.00000
## 5 0.52798 -0.20275 0.56409 -0.00712  0.34395 -0.27457 0.52940 -0.21780  0.45107
##        V20      V21      V22      V23      V24      V25      V26      V27
## 1 -0.32192  0.56971 -0.29674  0.36946 -0.47357  0.56811 -0.51171  0.41078
## 2 -1.00000 -0.13151 -0.45300 -0.18056 -0.35734 -0.20332 -0.26569 -0.20468
## 3 -0.08540  0.70887 -0.27502  0.43385 -0.12062  0.57528 -0.40220  0.58984
## 4 -0.54467 -0.69975  1.00000  0.00000  0.00000  1.00000  0.90695  0.51613
## 5 -0.17813  0.05982 -0.35575  0.02309 -0.52879  0.03286 -0.65158  0.13290
##        V28      V29      V30      V31      V32      V33      V34 Class
## 1 -0.46168  0.21266 -0.34090  0.42267 -0.54487  0.18641 -0.45300  good
## 2 -0.18401 -0.19040 -0.11593 -0.16626 -0.06288 -0.13738 -0.02447   bad
## 3 -0.22145  0.43100 -0.17365  0.60436 -0.24180  0.56045 -0.38238  good
## 4  1.00000  1.00000 -0.20099  0.25682  1.00000 -0.32382  1.00000   bad
## 5 -0.53206  0.02431 -0.62197 -0.05707 -0.59573 -0.04608 -0.65697  good&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Kiểm tra &lt;code&gt;missing values&lt;/code&gt; trong dữ liệu:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sum(is.na(dataset))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Kiểm tra phân phối của từng thuộc tính:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;summary(dataset)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  V1      V2            V3                V4                 V5         
##  0: 38   0:351   Min.   :-1.0000   Min.   :-1.00000   Min.   :-1.0000  
##  1:313           1st Qu.: 0.4721   1st Qu.:-0.06474   1st Qu.: 0.4127  
##                  Median : 0.8711   Median : 0.01631   Median : 0.8092  
##                  Mean   : 0.6413   Mean   : 0.04437   Mean   : 0.6011  
##                  3rd Qu.: 1.0000   3rd Qu.: 0.19418   3rd Qu.: 1.0000  
##                  Max.   : 1.0000   Max.   : 1.00000   Max.   : 1.0000  
##        V6                V7                V8                 V9          
##  Min.   :-1.0000   Min.   :-1.0000   Min.   :-1.00000   Min.   :-1.00000  
##  1st Qu.:-0.0248   1st Qu.: 0.2113   1st Qu.:-0.05484   1st Qu.: 0.08711  
##  Median : 0.0228   Median : 0.7287   Median : 0.01471   Median : 0.68421  
##  Mean   : 0.1159   Mean   : 0.5501   Mean   : 0.11936   Mean   : 0.51185  
##  3rd Qu.: 0.3347   3rd Qu.: 0.9692   3rd Qu.: 0.44567   3rd Qu.: 0.95324  
##  Max.   : 1.0000   Max.   : 1.0000   Max.   : 1.00000   Max.   : 1.00000  
##       V10                V11                V12                V13         
##  Min.   :-1.00000   Min.   :-1.00000   Min.   :-1.00000   Min.   :-1.0000  
##  1st Qu.:-0.04807   1st Qu.: 0.02112   1st Qu.:-0.06527   1st Qu.: 0.0000  
##  Median : 0.01829   Median : 0.66798   Median : 0.02825   Median : 0.6441  
##  Mean   : 0.18135   Mean   : 0.47618   Mean   : 0.15504   Mean   : 0.4008  
##  3rd Qu.: 0.53419   3rd Qu.: 0.95790   3rd Qu.: 0.48237   3rd Qu.: 0.9555  
##  Max.   : 1.00000   Max.   : 1.00000   Max.   : 1.00000   Max.   : 1.0000  
##       V14                V15               V16                V17         
##  Min.   :-1.00000   Min.   :-1.0000   Min.   :-1.00000   Min.   :-1.0000  
##  1st Qu.:-0.07372   1st Qu.: 0.0000   1st Qu.:-0.08170   1st Qu.: 0.0000  
##  Median : 0.03027   Median : 0.6019   Median : 0.00000   Median : 0.5909  
##  Mean   : 0.09341   Mean   : 0.3442   Mean   : 0.07113   Mean   : 0.3819  
##  3rd Qu.: 0.37486   3rd Qu.: 0.9193   3rd Qu.: 0.30897   3rd Qu.: 0.9357  
##  Max.   : 1.00000   Max.   : 1.0000   Max.   : 1.00000   Max.   : 1.0000  
##       V18                 V19               V20                V21         
##  Min.   :-1.000000   Min.   :-1.0000   Min.   :-1.00000   Min.   :-1.0000  
##  1st Qu.:-0.225690   1st Qu.: 0.0000   1st Qu.:-0.23467   1st Qu.: 0.0000  
##  Median : 0.000000   Median : 0.5762   Median : 0.00000   Median : 0.4991  
##  Mean   :-0.003617   Mean   : 0.3594   Mean   :-0.02402   Mean   : 0.3367  
##  3rd Qu.: 0.195285   3rd Qu.: 0.8993   3rd Qu.: 0.13437   3rd Qu.: 0.8949  
##  Max.   : 1.000000   Max.   : 1.0000   Max.   : 1.00000   Max.   : 1.0000  
##       V22                 V23               V24                V25         
##  Min.   :-1.000000   Min.   :-1.0000   Min.   :-1.00000   Min.   :-1.0000  
##  1st Qu.:-0.243870   1st Qu.: 0.0000   1st Qu.:-0.36689   1st Qu.: 0.0000  
##  Median : 0.000000   Median : 0.5318   Median : 0.00000   Median : 0.5539  
##  Mean   : 0.008296   Mean   : 0.3625   Mean   :-0.05741   Mean   : 0.3961  
##  3rd Qu.: 0.188760   3rd Qu.: 0.9112   3rd Qu.: 0.16463   3rd Qu.: 0.9052  
##  Max.   : 1.000000   Max.   : 1.0000   Max.   : 1.00000   Max.   : 1.0000  
##       V26                V27               V28                V29         
##  Min.   :-1.00000   Min.   :-1.0000   Min.   :-1.00000   Min.   :-1.0000  
##  1st Qu.:-0.33239   1st Qu.: 0.2864   1st Qu.:-0.44316   1st Qu.: 0.0000  
##  Median :-0.01505   Median : 0.7082   Median :-0.01769   Median : 0.4966  
##  Mean   :-0.07119   Mean   : 0.5416   Mean   :-0.06954   Mean   : 0.3784  
##  3rd Qu.: 0.15676   3rd Qu.: 0.9999   3rd Qu.: 0.15354   3rd Qu.: 0.8835  
##  Max.   : 1.00000   Max.   : 1.0000   Max.   : 1.00000   Max.   : 1.0000  
##       V30                V31               V32                 V33         
##  Min.   :-1.00000   Min.   :-1.0000   Min.   :-1.000000   Min.   :-1.0000  
##  1st Qu.:-0.23689   1st Qu.: 0.0000   1st Qu.:-0.242595   1st Qu.: 0.0000  
##  Median : 0.00000   Median : 0.4428   Median : 0.000000   Median : 0.4096  
##  Mean   :-0.02791   Mean   : 0.3525   Mean   :-0.003794   Mean   : 0.3494  
##  3rd Qu.: 0.15407   3rd Qu.: 0.8576   3rd Qu.: 0.200120   3rd Qu.: 0.8138  
##  Max.   : 1.00000   Max.   : 1.0000   Max.   : 1.000000   Max.   : 1.0000  
##       V34            Class    
##  Min.   :-1.00000   bad :126  
##  1st Qu.:-0.16535   good:225  
##  Median : 0.00000             
##  Mean   : 0.01448             
##  3rd Qu.: 0.17166             
##  Max.   : 1.00000&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Thuộc tính thứ &lt;code&gt;V2&lt;/code&gt; chỉ có 1 giá trị là &lt;code&gt;0&lt;/code&gt; nên có thể loại bỏ:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dataset$V2 &amp;lt;- NULL&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Chuyển thuộc tính &lt;code&gt;V1&lt;/code&gt; từ &lt;code&gt;factor&lt;/code&gt; sang &lt;code&gt;numeric&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dataset$V1 &amp;lt;- as.numeric(as.character(dataset$V1))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Kiểm tra mức độ tương quan (&lt;code&gt;correlation&lt;/code&gt;) giữa các thuộc tính (do số lượng thuộc tính lớn nên tôi chỉ hiển thị tương quan giữa 6 thuộc tính đầu làm mẫu):&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;cor(dataset[,1:6])&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##              V1         V3           V4         V5          V6          V7
## V1  1.000000000 0.30203392 -0.006528852 0.15615240  0.12760571  0.22186692
## V3  0.302033923 1.00000000  0.143364804 0.47658695  0.02576751  0.44025437
## V4 -0.006528852 0.14336480  1.000000000 0.00115185 -0.19030761 -0.05402953
## V5  0.156152397 0.47658695  0.001151850 1.00000000  0.03832312  0.59707508
## V6  0.127605707 0.02576751 -0.190307607 0.03832312  1.00000000 -0.01022692
## V7  0.221866916 0.44025437 -0.054029528 0.59707508 -0.01022692  1.00000000&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2.1.2 Trực quan hóa dữ liệu (&lt;code&gt;data visualization&lt;/code&gt;)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Do số lượng thuộc tính nhiều nên tôi chỉ thực hiện &lt;code&gt;data visualization&lt;/code&gt; đối 12 thuộc tính đầu của tập dữ liệu.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Histogram&lt;/code&gt; cho 12 thuộc tính đầu:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;par(mfrow=c(3,4))
for(i in 1:12) { 
  hist(dataset[,i], main=names(dataset)[i], breaks = 30)
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/ensemble-learning/index_files/figure-html/unnamed-chunk-13-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Boxplot&lt;/code&gt; cho 12 thuộc tính đầu:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;boxplot(dataset[, 1:12], col = &amp;quot;orange&amp;quot;, main = &amp;quot;Features Boxplot&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/ensemble-learning/index_files/figure-html/unnamed-chunk-14-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Trong bước này nếu phát hiện trong các thuộc tính có nhiều giá trị ngoại lai (&lt;code&gt;outliers&lt;/code&gt;) thì các bạn có thể đọc post trước của tôi về cách loại bỏ &lt;code&gt;outliers&lt;/code&gt; trong dữ liệu cho &lt;code&gt;machine learning&lt;/code&gt; bằng các phương pháp thống kê tại &lt;a href=&#34;https://svcuong.github.io/post/remove-outliers/&#34;&gt;đây&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.1.3 Tiền xử lý dữ liệu (&lt;code&gt;data preprocessing&lt;/code&gt;)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Xác định và Loại bỏ các thuộc tính tương quan với nhau cao (&amp;gt;0.75)&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Tìm các thuộc tính tương quan với nhau cao
cor_coefficient &amp;lt;- 0.75
correlations &amp;lt;- cor(dataset[,1:13])
highlyCorrelated &amp;lt;- findCorrelation(correlations, cutoff=cor_coefficient)
length(highlyCorrelated)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ở đây không có các thuộc tính tương quan cao với nhau, tuy nhiên nếu có thì các bạn có thể loại bỏ chúng như sau:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;datasetFeatures &amp;lt;- dataset[,-highlyCorrelated]
dim(datasetFeatures)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Chuẩn hóa giá trị của các thuộc tính (&lt;code&gt;data normalization&lt;/code&gt;) về khoảng &lt;code&gt;[0,1]&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;preProcValues &amp;lt;- preProcess(dataset, method = c(&amp;quot;range&amp;quot;))
data_processed &amp;lt;- predict(preProcValues, dataset)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Vậy là dữ liệu của chúng ta đã sẵn sàng để &lt;code&gt;test&lt;/code&gt; các thuật toán &lt;code&gt;ensemble learning&lt;/code&gt; rồi.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.2. Thuật toán Boosting&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Trong phạm vi post này tôi sẽ test hai thuật toán &lt;code&gt;boosting&lt;/code&gt; khá phổ biến là: &lt;code&gt;C5.0&lt;/code&gt; và &lt;code&gt;Stochastic Gradient Boosting&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Dưới đây là ví dụ huấn luyện hai mô hình này trên &lt;code&gt;R&lt;/code&gt; với các tham số mặc định:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;seed &amp;lt;- 10
# tạo một đối tượng control cho cross-validation
control &amp;lt;- trainControl(method=&amp;quot;repeatedcv&amp;quot;, number=10, repeats=3)
# Trong đó
# method = &amp;#39;repeatedcv&amp;#39;: sử dụng cross-validation với các tham số sau:
# number = 10 có nhĩa là quá trình cross-validation cần chia dữ liệu gốc thành 10 phần bằng nhau
# repeats = 3 có nhĩa là quá trình cross-validation sẽ hoàn thành sau 3 lần

# C5.0
set.seed(seed)
fit.c50 &amp;lt;- train(Class~., data=dataset, method=&amp;quot;C5.0&amp;quot;, metric = &amp;quot;Accuracy&amp;quot;, trControl=control)

# Stochastic Gradient Boosting
set.seed(seed)
fit.gbm &amp;lt;- train(Class~., data=dataset, method=&amp;quot;gbm&amp;quot;, metric = &amp;quot;Accuracy&amp;quot;, trControl=control, verbose=FALSE)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So sánh kết quả hai mô hình:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;boosting_results &amp;lt;- resamples(list(c5.0=fit.c50, gbm=fit.gbm))
summary(boosting_results)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## summary.resamples(object = boosting_results)
## 
## Models: c5.0, gbm 
## Number of resamples: 30 
## 
## Accuracy 
##           Min.   1st Qu.    Median      Mean   3rd Qu. Max. NA&amp;#39;s
## c5.0 0.8823529 0.9148810 0.9575163 0.9468627 0.9714286    1    0
## gbm  0.8529412 0.9166667 0.9428571 0.9420184 0.9714286    1    0
## 
## Kappa 
##           Min.   1st Qu.    Median      Mean  3rd Qu. Max. NA&amp;#39;s
## c5.0 0.7213115 0.8157164 0.9069808 0.8806722 0.937833    1    0
## gbm  0.6586345 0.8142060 0.8776224 0.8707906 0.937201    1    0&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dotplot(boosting_results)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/ensemble-learning/index_files/figure-html/unnamed-chunk-19-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Từ kết quả so sánh ta thấy thuật toán &lt;code&gt;C5.0&lt;/code&gt; cho kết quả chính xác hơn so với &lt;code&gt;Stochastic Gradient Boosting&lt;/code&gt; trong bài toán này (với độ chính xác là &lt;code&gt;94.68%&lt;/code&gt;)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.3 Thuật toán Bagging&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Chúng ta cùng test hai thuật toán thuộc kỹ thuật &lt;code&gt;Bagging&lt;/code&gt; là: &lt;code&gt;Bagged CART&lt;/code&gt; và &lt;code&gt;Random Forest&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Dưới đây là ví dụ huấn luyện hai mô hình này trên &lt;code&gt;R&lt;/code&gt; với các tham số mặc định:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;control &amp;lt;- trainControl(method=&amp;quot;repeatedcv&amp;quot;, number=10, repeats=3)

# Bagged CART
set.seed(seed)
fit.treebag &amp;lt;- train(Class~., data=dataset, method=&amp;quot;treebag&amp;quot;, metric = &amp;quot;Accuracy&amp;quot;, trControl=control)

# Random Forest
set.seed(seed)
fit.rf &amp;lt;- train(Class~., data=dataset, method=&amp;quot;rf&amp;quot;, metric = &amp;quot;Accuracy&amp;quot;, trControl=control)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So sánh kết quả hai mô hình:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;bagging_results &amp;lt;- resamples(list(treebag=fit.treebag, rf=fit.rf))
summary(bagging_results)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## summary.resamples(object = bagging_results)
## 
## Models: treebag, rf 
## Number of resamples: 30 
## 
## Accuracy 
##              Min.   1st Qu.    Median      Mean   3rd Qu.      Max. NA&amp;#39;s
## treebag 0.8285714 0.8922269 0.9428571 0.9210566 0.9440476 0.9722222    0
## rf      0.8235294 0.9142857 0.9428571 0.9343946 0.9714286 1.0000000    0
## 
## Kappa 
##              Min.   1st Qu.    Median      Mean   3rd Qu.      Max. NA&amp;#39;s
## treebag 0.6209386 0.7708291 0.8731884 0.8266350 0.8770749 0.9407895    0
## rf      0.5984252 0.8149436 0.8734173 0.8550575 0.9372010 1.0000000    0&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dotplot(bagging_results)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/ensemble-learning/index_files/figure-html/unnamed-chunk-21-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Từ kết quả so sánh ta thấy thuật toán &lt;code&gt;Random Forest&lt;/code&gt; cho kết quả chính xác hơn so với &lt;code&gt;CART&lt;/code&gt; trong bài toán này (với độ chính xác là &lt;code&gt;93.44%&lt;/code&gt;). Tuy nhiên cả hai thuật toán &lt;code&gt;Bagging&lt;/code&gt; đều có độ chính xác nhỏ hơn so với 2 thuật toán &lt;code&gt;Boosting&lt;/code&gt; trước.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.4. Thuật toán Stacking&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Để kết hợp các mô hình &lt;code&gt;machine learning&lt;/code&gt; khác nhau trong &lt;code&gt;R&lt;/code&gt; chúng ta sử dụng thư viện &lt;strong&gt;caretEnsemble&lt;/strong&gt;. Với danh sách các &lt;code&gt;caret models&lt;/code&gt;, hàm &lt;code&gt;caretStack()&lt;/code&gt; của gói này có thể sự dụng để chỉ định mô hình bậc cao hơn, từ đó sẽ học cách tìm sự kết hợp tốt nhất những &lt;code&gt;sub-models&lt;/code&gt; với nhau.&lt;/p&gt;
&lt;p&gt;Ở ví dụ này, tôi sẽ sử dụng 5 &lt;code&gt;sub-models&lt;/code&gt; sau cho tập dữ liệu &lt;code&gt;ionosphere&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Linear Discriminate Analysis (&lt;code&gt;LDA&lt;/code&gt;)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Classification and Regression Trees (&lt;code&gt;CART&lt;/code&gt;)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Logistic Regression (&lt;code&gt;GLM&lt;/code&gt;)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;k-Nearest Neighbors (&lt;code&gt;kNN&lt;/code&gt;)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Support Vector Machine with a Radial Basis Kernel Function (&lt;code&gt;SVM&lt;/code&gt;)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Dưới đây là ví dụ huấn luyện 5 mô hình này trên &lt;code&gt;R&lt;/code&gt; với các tham số mặc định:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;control &amp;lt;- trainControl(method=&amp;quot;repeatedcv&amp;quot;, number=10, repeats=3, savePredictions=TRUE, classProbs=TRUE)
algorithmList &amp;lt;- c(&amp;#39;lda&amp;#39;, &amp;#39;rpart&amp;#39;, &amp;#39;glm&amp;#39;, &amp;#39;knn&amp;#39;, &amp;#39;svmRadial&amp;#39;)
set.seed(seed)
models &amp;lt;- caretList(Class~., data=dataset, trControl=control, methodList=algorithmList)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So sánh kết quả các mô hình:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;results &amp;lt;- resamples(models)
summary(results)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## summary.resamples(object = results)
## 
## Models: lda, rpart, glm, knn, svmRadial 
## Number of resamples: 30 
## 
## Accuracy 
##                Min.   1st Qu.    Median      Mean   3rd Qu.      Max. NA&amp;#39;s
## lda       0.7941176 0.8297619 0.8571429 0.8669546 0.9136555 0.9428571    0
## rpart     0.8000000 0.8529412 0.8611111 0.8736819 0.9079365 0.9714286    0
## glm       0.7428571 0.8539916 0.8823529 0.8824214 0.9166667 0.9714286    0
## knn       0.7500000 0.8235294 0.8333333 0.8403097 0.8601190 0.9444444    0
## svmRadial 0.8888889 0.9142857 0.9436508 0.9477591 0.9714286 1.0000000    0
## 
## Kappa 
##                Min.   1st Qu.    Median      Mean   3rd Qu.      Max. NA&amp;#39;s
## lda       0.4803493 0.6048824 0.6697323 0.6868903 0.8032314 0.8679245    0
## rpart     0.5648313 0.6586345 0.7024010 0.7193438 0.7900135 0.9397590    0
## glm       0.4578313 0.6618591 0.7267975 0.7371380 0.8163265 0.9368030    0
## knn       0.4087591 0.5641026 0.6196004 0.6199654 0.6770575 0.8754325    0
## svmRadial 0.7419355 0.8142060 0.8776224 0.8847121 0.9375755 1.0000000    0&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dotplot(results)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/ensemble-learning/index_files/figure-html/unnamed-chunk-23-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Ta thấy trong các mô hình này thì &lt;code&gt;SVM&lt;/code&gt; cho kết quả chính xác nhất (&lt;code&gt;94.78%&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Giờ chúng ta hãy thử dùng kỹ thuật &lt;code&gt;stacking&lt;/code&gt; để xem có thể cải thiện được độ chính xác không.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;Lưu ý&lt;/code&gt;:&lt;/strong&gt; Khi các bạn muốn kết hợp các mô hình với nhau sử dụng kỹ thuật &lt;code&gt;stacking&lt;/code&gt;, thì các bạn cần kiểm chứng rằng kết quả dự báo từ các mô hình này tương quan với nhau thấp. Nếu kết quả dự báo của các &lt;code&gt;sub-models&lt;/code&gt; tương quan cao với nhau (&amp;gt; 0.75) thì có nghĩa là chúng sẽ cho kết quả dự báo tương tự nhau, điều này sẽ làm giảm hiệu quả khi ta kết hợp các mô hình này với nhau.&lt;/p&gt;
&lt;p&gt;Kiểm tra độ tương quan giữa các &lt;code&gt;sub-models&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;modelCor(results)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##                 lda       rpart         glm       knn svmRadial
## lda       1.0000000 0.379461533 0.277037721 0.4898435 0.3056838
## rpart     0.3794615 1.000000000 0.001889458 0.4040556 0.2539580
## glm       0.2770377 0.001889458 1.000000000 0.1466240 0.4296011
## knn       0.4898435 0.404055597 0.146623958 1.0000000 0.5495574
## svmRadial 0.3056838 0.253957967 0.429601141 0.5495574 1.0000000&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;splom(results)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/ensemble-learning/index_files/figure-html/unnamed-chunk-24-1.png&#34; width=&#34;960&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Nhìn vào kết quả ta có thể thấy các &lt;code&gt;su-models&lt;/code&gt; cho kết quả dự báo tương quan với nhau thấp theo từng cặp. Cặp tương quan với nhau nhất là &lt;code&gt;SVM&lt;/code&gt; và &lt;code&gt;kNN&lt;/code&gt; với độ tương quan &lt;code&gt;0.549&lt;/code&gt;, cũng vẫn nhỏ hơn mức quy địn là cao (&lt;code&gt;&amp;gt;0.75&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Nào chúng ta hãy thử kết hợp &lt;code&gt;predictions&lt;/code&gt; của các &lt;code&gt;sub-models&lt;/code&gt; sử dụng mô hình &lt;code&gt;gml&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;stackControl &amp;lt;- trainControl(method=&amp;quot;repeatedcv&amp;quot;, number=10, repeats=3, savePredictions=TRUE, classProbs=TRUE)
set.seed(seed)
stack.glm &amp;lt;- caretStack(models, method=&amp;quot;glm&amp;quot;, metric=&amp;quot;Accuracy&amp;quot;, trControl=stackControl)
print(stack.glm)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## A glm ensemble of 5 base models: lda, rpart, glm, knn, svmRadial
## 
## Ensemble results:
## Generalized Linear Model 
## 
## 1053 samples
##    5 predictor
##    2 classes: &amp;#39;bad&amp;#39;, &amp;#39;good&amp;#39; 
## 
## No pre-processing
## Resampling: Cross-Validated (10 fold, repeated 3 times) 
## Summary of sample sizes: 947, 947, 947, 948, 947, 949, ... 
## Resampling results:
## 
##   Accuracy   Kappa    
##   0.9544285  0.9003902&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Độ chính xác cải thiện lên &lt;code&gt;95.44%&lt;/code&gt; so với chỉ sử dụng &lt;code&gt;SVM model&lt;/code&gt; là &lt;code&gt;94.78%&lt;/code&gt;, tuy nhiên cũng chưa có độ chênh lệnh nhiều.&lt;/p&gt;
&lt;p&gt;Tiếp theo tôi thử thử kết hợp &lt;code&gt;predictions&lt;/code&gt; của các &lt;code&gt;sub-models&lt;/code&gt; sử dụng mô hình &lt;code&gt;random forest&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;set.seed(seed)
stack.rf &amp;lt;- caretStack(models, method=&amp;quot;rf&amp;quot;, metric=&amp;quot;Accuracy&amp;quot;, trControl=stackControl)
print(stack.rf)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## A rf ensemble of 5 base models: lda, rpart, glm, knn, svmRadial
## 
## Ensemble results:
## Random Forest 
## 
## 1053 samples
##    5 predictor
##    2 classes: &amp;#39;bad&amp;#39;, &amp;#39;good&amp;#39; 
## 
## No pre-processing
## Resampling: Cross-Validated (10 fold, repeated 3 times) 
## Summary of sample sizes: 947, 947, 947, 948, 947, 949, ... 
## Resampling results across tuning parameters:
## 
##   mtry  Accuracy   Kappa    
##   2     0.9623381  0.9177343
##   3     0.9588700  0.9103978
##   5     0.9569833  0.9064705
## 
## Accuracy was used to select the optimal model using the largest value.
## The final value used for the model was mtry = 2.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Độ chính xác cũng cải thiện hơn so với chỉ dùng &lt;code&gt;svm model&lt;/code&gt; (&lt;code&gt;96.23%&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tham khảo:&lt;/strong&gt;
&lt;a href=&#34;https://machinelearningmastery.com/machine-learning-ensembles-with-r/&#34;&gt;How to Build an Ensemble Of Machine Learning Algorithms in R&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Cách scrape một trang web bằng R. Scrape và so sánh dữ liệu lịch sử thị trường  tiền điện tử từ CoinMarketCap</title>
      <link>/post/crypto/</link>
      <pubDate>Sat, 22 Aug 2020 00:00:00 +0000</pubDate>
      <guid>/post/crypto/</guid>
      <description>


&lt;p&gt;&lt;strong&gt;Web scraping&lt;/strong&gt; là công việc trích xuất dữ liệu từ một trang web. Trong thực tế đôi khi bạn cần thu thập 1 số lượng lớn thông tin từ một số trang web như là giá cổ phiếu, chi tiết sản phẩm, số liệu thống kê thể thao, thông tin liên hệ của công ty,…để phục vụ cho nhiều mục đích khác nhau. Tuy nhiên, việc lấy các thông tin này một cách thủ công thì cần rất nhiều thời gian. Lúc này web scraping chính là cách giúp chúng ta trích xuất dữ liệu từ các trang web một cách tự động. Kỹ thuật này chủ yếu tập trung vào việc chuyển đổi dữ liệu phi cấu trúc (HTML) trên web thành dữ liệu có cấu trúc (cơ sở dữ liệu, bảng tính,…)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CoinMarketCap&lt;/strong&gt; là một trang web chuyên cung cấp dữ liệu về các loại tiền điện tử đang được lưu hành trên thế giới. Nếu bạn là người đã hoặc đang tìm hiểu, đầu tư vào các đồng &lt;code&gt;coins&lt;/code&gt; thì không thể nào bỏ qua trang web cung cấp thông tin về tiền điện tử lớn nhất thế giới này. Với &lt;code&gt;CoinMarketCap&lt;/code&gt; bạn có thể xem rất nhiều lọai thông tin ví dụ như: biến động giá cả các đồng &lt;code&gt;coin&lt;/code&gt;, trữ lượng, khối lượng giao dịch theo từng khoảng thời gian, tỷ giá, xem trang web chính thức hoặc các hoạt động trên mạng xã hội của các đồng &lt;code&gt;coins&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Trong bài này tôi sẽ giới thiệu với các bạn cách sử dụng gói &lt;code&gt;rvest&lt;/code&gt; trong &lt;code&gt;R&lt;/code&gt; để &lt;code&gt;scrape&lt;/code&gt; dữ liệu lịch sử thị trường các loại tiền điện tử từ &lt;code&gt;CoinMarketCap&lt;/code&gt;. Sau đó dùng gói &lt;code&gt;ggplot2&lt;/code&gt; để trực quan hóa dữ liệu nhằm mục đích so sánh biến động giá cả của các đồng coins với nhau trong khoảng thời gian nhất định.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Gói rvest&lt;/strong&gt; cũng giống như thư viện &lt;code&gt;BeautifulSoup&lt;/code&gt; trên &lt;code&gt;Python&lt;/code&gt;, là một thư viện &lt;code&gt;R&lt;/code&gt; để trích xuất dữ liệu từ các tập tin &lt;code&gt;HTML&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Lưu ý khi scape một trang web:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Không nên tạo quá nhiều &lt;code&gt;request&lt;/code&gt; đến trang web trong 1 thời điểm, vì nó có thể gây ra sập trang web (có thể bị liệt vào tấn công từ chối dịch vụ &lt;code&gt;DDoS&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Trang web có thể sẽ thường xuyên thay đổi giao diện, bố cục (&lt;code&gt;HTML&lt;/code&gt;) nên bạn cần thường xuyên cập nhật &lt;code&gt;code&lt;/code&gt; của mình&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Nạp các thư viện cần dùng vào phiên làm việc của &lt;code&gt;R&lt;/code&gt; để thực hành:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(jsonlite) # Thư viện cho phép đọc json files
library(rvest) # thư viện để scape web
library(viridis) # Thay đổi bảng màu mặc định ggplot2
library(tidyverse) # Hệ sinh thái các gói hỗ trợ biến đổi (dplyr) và trực quan hóa dữ liệu (ggplot2)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Nếu chưa cài các thư viện trên thì các bạn dùng lệnh &lt;code&gt;install.packages(.)&lt;/code&gt; để cài đặt với tham số đầu vào là tên các thư viện cần cài đặt. Ví dụ:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;install.packages(&amp;quot;rvest&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Đầu tiên chúng ta đọc &lt;code&gt;json&lt;/code&gt; file từ trang &lt;code&gt;CoinMarketCap&lt;/code&gt; để biết thông tin về các loại &lt;code&gt;coins&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;json &amp;lt;- &amp;quot;https://s2.coinmarketcap.com/generated/search/quick_search.json&amp;quot;
coins &amp;lt;- read_json(json, simplifyVector = TRUE)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Hiển thị bảng thông tin 10 đồng &lt;code&gt;coins&lt;/code&gt; đầu tiên theo &lt;code&gt;rank&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;head(coins,10)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##               name symbol rank            slug
## 1          Bitcoin    BTC    1         bitcoin
## 2         Ethereum    ETH    2        ethereum
## 3              XRP    XRP    3             xrp
## 4           Tether   USDT    4          tether
## 5     Bitcoin Cash    BCH    5    bitcoin-cash
## 6        Chainlink   LINK    6       chainlink
## 7         Litecoin    LTC    7        litecoin
## 8       Bitcoin SV    BSV    8      bitcoin-sv
## 9          Cardano    ADA    9         cardano
## 10 Crypto.com Coin    CRO   10 crypto-com-coin
##                                   tokens   id
## 1                  Bitcoin, bitcoin, BTC    1
## 2                Ethereum, ethereum, ETH 1027
## 3                          XRP, xrp, XRP   52
## 4                   Tether, tether, USDT  825
## 5        Bitcoin Cash, bitcoin-cash, BCH 1831
## 6             Chainlink, chainlink, LINK 1975
## 7                Litecoin, litecoin, LTC    2
## 8            Bitcoin SV, bitcoin-sv, BSV 3602
## 9                  Cardano, cardano, ADA 2010
## 10 Crypto.com Coin, crypto-com-coin, CRO 3635&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Kiểm tra tổng số lượng đồng tiền kỹ thuật số đang lưu hành trên &lt;code&gt;CoinMarketCap&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dim(coins)[1]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 4812&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Để ví dụ, trong bài này tôi sẽ so sánh thông tin 10 đồng &lt;code&gt;coins&lt;/code&gt; đầu tiên có rank từ 2 đến 11:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Lấy thông tin về tên, symbol và slug của 10 đồng coins có rank = [2:11]
coinslug &amp;lt;- coins$slug[2:11]
coinname &amp;lt;- coins$name[2:11]
coinsymbol &amp;lt;- coins$symbol[2:11]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Tạo hàm để get dữ liệu coins.&lt;/strong&gt; Khi ta vào mục &lt;code&gt;historical data&lt;/code&gt; (như hình bên dưới) để xem thông tin của từng loại &lt;code&gt;coin&lt;/code&gt; trên trang &lt;code&gt;CoinMarketCap&lt;/code&gt;, ta thấy trong đường &lt;code&gt;link&lt;/code&gt; có &lt;code&gt;3&lt;/code&gt; thông tin quan trọng đó là:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;slug&lt;/code&gt;: Slug của loại coin đó (như đường link trong hình dưới là &lt;code&gt;bitcoin&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;start&lt;/code&gt;: Ngày bắt đầu của khoảng thời gian ta muốn xem thông tin&lt;/li&gt;
&lt;li&gt;&lt;code&gt;end&lt;/code&gt;: ngày kết thúc của khoảng thời gian ta muốn xem thông tin&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;/post/2020-08-21-crypto.vn_files/bitcoin.PNG&#34; alt=&#34;Screenshot từ trang CoinMarketCap&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;&lt;code&gt;Screenshot&lt;/code&gt; từ trang &lt;a href=&#34;https://coinmarketcap.com/currencies/bitcoin/historical-data/?start=20200722&amp;amp;end=20200822&#34;&gt;CoinMarketCap&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Vì vậy ta sẽ viết hàm để &lt;code&gt;get&lt;/code&gt; dữ liệu dựa vào &lt;code&gt;3&lt;/code&gt; thông tin trên như sau:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Tạo hàm get dữ liệu coin
get_data_coin &amp;lt;- function(coin, start_date, end_date){
  # coin: slug của coin
  # start_date: Ngày bắt đầu lấy dữ liệu
  # end_date: Ngày kết thúc lấy dữ liệu
  # Tạo đường link từ 3 thông tin đầu vào
  historyurl &amp;lt;- paste0(&amp;quot;https://coinmarketcap.com/currencies/&amp;quot;,
                      coin,
                      &amp;quot;/historical-data/?start=&amp;quot;,
                      start_date,
                      &amp;quot;&amp;amp;end=&amp;quot;,
                      end_date)
  
  # Đọc dữ liệu từ web
  url &amp;lt;-read_html(historyurl)
  data &amp;lt;- data.frame(html_table(url)[[3]])
  data$Slug &amp;lt;- coin
  return(data)
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ví dụ sử dụng hàm &lt;code&gt;get_data_coin()&lt;/code&gt; vừa tạo để lấy dữ liệu lịch sử của &lt;code&gt;10&lt;/code&gt; loại coins trên từ ngày &lt;code&gt;21/08/2019&lt;/code&gt; dến ngày &lt;code&gt;21/08/2020&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Nhập ngày bắt đầu và và kết thúc trong khoảng thời gian muốn xem theo định đạng &amp;quot;Năm-Tháng-Ngày&amp;quot;
start_date = 20190821
end_date = 20200821
# Tạo list trống để lưu dữ liệu coins
results_data &amp;lt;- list()

# Lưu dữ liệu từng loại coin trong danh sách 10 coins ở trên vào list trống
for (i in (1:length(coinslug))){
  results_data[[i]] &amp;lt;- get_data_coin(coin = coinslug[i], start_date = start_date, end_date = end_date)
}

# Gộp data.frame của từng loại coin trong list vào thành 1 bảng
results_data &amp;lt;- do.call(rbind, results_data)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Để kiểm tra dữ liệu thu được, ta hiển thị &lt;code&gt;10&lt;/code&gt; hàng dữ liệu đầu tiên trong bẳng bằng lệnh &lt;code&gt;head()&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;head(results_data, 10)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##            Date  Open.   High    Low Close..         Volume     Market.Cap
## 1  Aug 21, 2020 416.15 418.64 387.44  389.13 11,781,796,374 43,690,315,907
## 2  Aug 20, 2020 406.76 418.73 404.03  416.44 10,043,032,427 46,751,356,941
## 3  Aug 19, 2020 423.74 427.02 396.68  406.46 13,137,391,167 45,625,864,918
## 4  Aug 18, 2020 429.67 432.58 419.67  423.67 11,978,984,079 47,551,407,033
## 5  Aug 17, 2020 433.97 442.73 422.65  429.53 13,227,089,410 48,203,426,751
## 6  Aug 16, 2020 433.35 436.27 415.09  433.79 12,168,816,874 48,675,162,267
## 7  Aug 15, 2020 437.56 441.75 429.87  433.35 12,416,067,894 48,620,820,125
## 8  Aug 14, 2020 428.68 444.58 423.35  437.40 15,064,589,987 49,068,474,083
## 9  Aug 13, 2020 390.84 432.90 379.71  428.74 18,480,303,526 48,091,569,052
## 10 Aug 12, 2020 380.06 391.31 367.92  391.02 12,408,772,745 43,855,501,072
##        Slug
## 1  ethereum
## 2  ethereum
## 3  ethereum
## 4  ethereum
## 5  ethereum
## 6  ethereum
## 7  ethereum
## 8  ethereum
## 9  ethereum
## 10 ethereum&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Thêm thông tin gồm &lt;code&gt;name&lt;/code&gt; và &lt;code&gt;symbol&lt;/code&gt; của từng &lt;code&gt;coin&lt;/code&gt; vào bảng dữ liệu:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;coinnames &amp;lt;- data.frame(
        Name = as.character(coinname),
        Symbol = as.character(coinsymbol),
        Slug = as.character(coinslug))
df &amp;lt;- full_join(coinnames, results_data, by = &amp;quot;Slug&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Để kiểm tra bảng dữ liệu mới thu được, ta hiển thị &lt;code&gt;10&lt;/code&gt; hàng dữ liệu đầu tiên trong bảng:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;head(df, 10)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##        Name Symbol     Slug         Date  Open.   High    Low Close..
## 1  Ethereum    ETH ethereum Aug 21, 2020 416.15 418.64 387.44  389.13
## 2  Ethereum    ETH ethereum Aug 20, 2020 406.76 418.73 404.03  416.44
## 3  Ethereum    ETH ethereum Aug 19, 2020 423.74 427.02 396.68  406.46
## 4  Ethereum    ETH ethereum Aug 18, 2020 429.67 432.58 419.67  423.67
## 5  Ethereum    ETH ethereum Aug 17, 2020 433.97 442.73 422.65  429.53
## 6  Ethereum    ETH ethereum Aug 16, 2020 433.35 436.27 415.09  433.79
## 7  Ethereum    ETH ethereum Aug 15, 2020 437.56 441.75 429.87  433.35
## 8  Ethereum    ETH ethereum Aug 14, 2020 428.68 444.58 423.35  437.40
## 9  Ethereum    ETH ethereum Aug 13, 2020 390.84 432.90 379.71  428.74
## 10 Ethereum    ETH ethereum Aug 12, 2020 380.06 391.31 367.92  391.02
##            Volume     Market.Cap
## 1  11,781,796,374 43,690,315,907
## 2  10,043,032,427 46,751,356,941
## 3  13,137,391,167 45,625,864,918
## 4  11,978,984,079 47,551,407,033
## 5  13,227,089,410 48,203,426,751
## 6  12,168,816,874 48,675,162,267
## 7  12,416,067,894 48,620,820,125
## 8  15,064,589,987 49,068,474,083
## 9  18,480,303,526 48,091,569,052
## 10 12,408,772,745 43,855,501,072&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ta thấy cột &lt;code&gt;Date&lt;/code&gt; ở dạng &lt;code&gt;character&lt;/code&gt; nên cần chuyển về dạng &lt;code&gt;date&lt;/code&gt; như sau:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;df$Date &amp;lt;- lubridate::mdy(unlist(df$Date))
head(df, 10)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##        Name Symbol     Slug       Date  Open.   High    Low Close..
## 1  Ethereum    ETH ethereum 2020-08-21 416.15 418.64 387.44  389.13
## 2  Ethereum    ETH ethereum 2020-08-20 406.76 418.73 404.03  416.44
## 3  Ethereum    ETH ethereum 2020-08-19 423.74 427.02 396.68  406.46
## 4  Ethereum    ETH ethereum 2020-08-18 429.67 432.58 419.67  423.67
## 5  Ethereum    ETH ethereum 2020-08-17 433.97 442.73 422.65  429.53
## 6  Ethereum    ETH ethereum 2020-08-16 433.35 436.27 415.09  433.79
## 7  Ethereum    ETH ethereum 2020-08-15 437.56 441.75 429.87  433.35
## 8  Ethereum    ETH ethereum 2020-08-14 428.68 444.58 423.35  437.40
## 9  Ethereum    ETH ethereum 2020-08-13 390.84 432.90 379.71  428.74
## 10 Ethereum    ETH ethereum 2020-08-12 380.06 391.31 367.92  391.02
##            Volume     Market.Cap
## 1  11,781,796,374 43,690,315,907
## 2  10,043,032,427 46,751,356,941
## 3  13,137,391,167 45,625,864,918
## 4  11,978,984,079 47,551,407,033
## 5  13,227,089,410 48,203,426,751
## 6  12,168,816,874 48,675,162,267
## 7  12,416,067,894 48,620,820,125
## 8  15,064,589,987 49,068,474,083
## 9  18,480,303,526 48,091,569,052
## 10 12,408,772,745 43,855,501,072&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Dùng thư viện &lt;code&gt;ggplot2&lt;/code&gt; để trực quan hóa và so sánh biến động giá cả của các loại &lt;code&gt;coins&lt;/code&gt; trong khoảng thời gian từ ngày &lt;code&gt;21/08/2019&lt;/code&gt; dến ngày &lt;code&gt;21/08/2020&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Chỉ so sánh thông tìn các cột Open, High, Low, Close
df &amp;lt;- df[,1:8]

# Chuyển bẳng dữ liệu từ dạng bảng rộng về dài
library(tidyr)
df$Name&amp;lt;- factor(df$Name)
df_tall &amp;lt;- df%&amp;gt;% gather(key = s, value = value, -Name, -Symbol, -Slug, -Date)
df_tall$s &amp;lt;- factor(df_tall$s, levels=unique(as.character(df_tall$s)))

# Vẽ biểu đồ so sánh thông tin
ggplot(df_tall, aes(x = Date, y = value, color = Name)) +
geom_line(size = 0.75) +
xlab(&amp;quot;Time&amp;quot;)+
facet_wrap(~s, ncol = 2, scales = &amp;quot;free_y&amp;quot;)+
theme_bw()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/crypto/index_files/figure-html/unnamed-chunk-13-1.png&#34; width=&#34;1152&#34; /&gt;
Khi đã có dữ liệu rồi tiếp theo chúng ta có thể xây dựng các mô hình dự báo để đự đoán giá các loại &lt;code&gt;coins&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Chú thích:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Open&lt;/code&gt;: Giá mở cửa&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Close&lt;/code&gt;: Giá đóng cửa&lt;/li&gt;
&lt;li&gt;&lt;code&gt;High&lt;/code&gt;: Mức giá cao nhất&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Low&lt;/code&gt;: Mức giá thấp nhất&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;4&lt;/code&gt; bộ phận này cấu thành nên một &lt;code&gt;nến&lt;/code&gt; giao dịch đại diện cho sự lên xuống của giá trị một loại tài sản trong một khoảng thời gian cố định. Điểm &lt;code&gt;“open”&lt;/code&gt; của nến đại diện cho mức giá của loại tài sản khi bắt đầu khoảng thời gian giao dịch, trong khi &lt;code&gt;“close”&lt;/code&gt; là mức giá khi kết thúc thời gian giao dịch. Còn &lt;code&gt;“high”&lt;/code&gt; và &lt;code&gt;“low”&lt;/code&gt; lần lượt là các mức giá cao nhất và thấp nhất đạt được trong phiên giao dịch.&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;/post/2020-08-21-crypto.vn_files/Candlestick-Anatomy.jpg&#34; alt=&#34;Các bộ phận của một nến giao dịch, với nến tăng (màu xanh) và nếu giảm (màu đỏ)&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;Các bộ phận của một nến giao dịch, với nến &lt;code&gt;tăng&lt;/code&gt; (màu xanh) và nếu &lt;code&gt;giảm&lt;/code&gt; (màu đỏ)&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>
